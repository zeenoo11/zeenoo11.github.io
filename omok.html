<!doctype html>
<html lang="ko">

<head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width,initial-scale=1" />
    <title>오목 게임</title>
    <style>
        /* 간단한 페이지 스타일 */
        body {
            font-family: system-ui, -apple-system, Segoe UI, Roboto, Helvetica, Arial, sans-serif;
            margin: 20px;
        }

        h1 {
            margin: 0 0 12px;
            font-size: 22px;
        }

        .toolbar {
            display: flex;
            gap: 8px;
            align-items: center;
            margin-bottom: 12px;
            flex-wrap: wrap;
        }

        button {
            padding: 8px 12px;
            cursor: pointer;
        }

        .status {
            font-weight: 600;
        }

        canvas {
            border: 1px solid #ccc;
            background: #f7f7f7;
            touch-action: manipulation;
        }

        .note {
            color: #666;
            font-size: 12px;
            margin-top: 8px;
        }

        a {
            color: #0366d6;
            text-decoration: none;
        }

        a:hover {
            text-decoration: underline;
        }
    </style>
</head>

<body>
    <h1>오목 (Gomoku)</h1>
    <div class="toolbar">
        <button id="resetBtn">리셋</button>
        <span class="status" id="status">검은돌 차례</span>
        <a href="index.html">홈으로</a>
    </div>
    <canvas id="board" width="600" height="600" aria-label="오목 바둑판"></canvas>
    <div class="note">모바일에서는 캔버스를 탭하여 돌을 놓을 수 있습니다.</div>

    <script>
        // 오목 기본 설정
        const BOARD_SIZE = 15; // 15x15
        const CELL_SIZE = 40; // 픽셀 크기
        const PADDING = 20; // 가장자리 여백
        const STONE_RADIUS = 16; // 돌 반지름

        const canvas = document.getElementById('board');
        const ctx = canvas.getContext('2d');
        const statusEl = document.getElementById('status');
        const resetBtn = document.getElementById('resetBtn');

        const canvasSize = PADDING * 2 + CELL_SIZE * (BOARD_SIZE - 1);
        canvas.width = canvas.height = canvasSize;

        // 보드: 0=빈칸, 1=흑, 2=백
        let board = Array.from({ length: BOARD_SIZE }, () => Array(BOARD_SIZE).fill(0));
        let current = 1; // 1=흑, 2=백
        let gameOver = false;

        function drawBoard() {
            ctx.clearRect(0, 0, canvas.width, canvas.height);
            // 배경
            ctx.fillStyle = '#f3e7c9';
            ctx.fillRect(0, 0, canvas.width, canvas.height);

            // 격자선
            ctx.strokeStyle = '#555';
            ctx.lineWidth = 1;
            for (let i = 0; i < BOARD_SIZE; i++) {
                const pos = PADDING + i * CELL_SIZE;
                // 가로선
                ctx.beginPath();
                ctx.moveTo(PADDING, pos);
                ctx.lineTo(PADDING + CELL_SIZE * (BOARD_SIZE - 1), pos);
                ctx.stroke();
                // 세로선
                ctx.beginPath();
                ctx.moveTo(pos, PADDING);
                ctx.lineTo(pos, PADDING + CELL_SIZE * (BOARD_SIZE - 1));
                ctx.stroke();
            }

            // 화점(중앙 등)
            const starCoords = [3, 7, 11];
            ctx.fillStyle = '#333';
            for (const i of starCoords) {
                for (const j of starCoords) {
                    const x = PADDING + i * CELL_SIZE;
                    const y = PADDING + j * CELL_SIZE;
                    ctx.beginPath();
                    ctx.arc(x, y, 3, 0, Math.PI * 2);
                    ctx.fill();
                }
            }

            // 돌 그리기
            for (let y = 0; y < BOARD_SIZE; y++) {
                for (let x = 0; x < BOARD_SIZE; x++) {
                    if (board[y][x] !== 0) {
                        drawStone(x, y, board[y][x] === 1 ? 'black' : 'white');
                    }
                }
            }
        }

        function drawStone(x, y, color) {
            const cx = PADDING + x * CELL_SIZE;
            const cy = PADDING + y * CELL_SIZE;

            // 바깥 그림자
            ctx.beginPath();
            ctx.arc(cx, cy, STONE_RADIUS + 0.5, 0, Math.PI * 2);
            ctx.fillStyle = color === 'black' ? 'rgba(0,0,0,0.35)' : 'rgba(0,0,0,0.15)';
            ctx.fill();

            // 본체
            const gradient = ctx.createRadialGradient(
                cx - 6,
                cy - 6,
                4,
                cx,
                cy,
                STONE_RADIUS
            );
            if (color === 'black') {
                gradient.addColorStop(0, '#666');
                gradient.addColorStop(1, '#111');
            } else {
                gradient.addColorStop(0, '#fff');
                gradient.addColorStop(1, '#ddd');
            }
            ctx.beginPath();
            ctx.arc(cx, cy, STONE_RADIUS, 0, Math.PI * 2);
            ctx.fillStyle = gradient;
            ctx.fill();

            // 테두리
            ctx.strokeStyle = '#444';
            ctx.lineWidth = 0.5;
            ctx.stroke();
        }

        function setStatus() {
            if (gameOver) return;
            statusEl.textContent = current === 1 ? '검은돌 차례' : '흰돌 차례';
        }

        function inBounds(x, y) {
            return x >= 0 && x < BOARD_SIZE && y >= 0 && y < BOARD_SIZE;
        }

        function checkWinAt(x, y) {
            const color = board[y][x];
            if (!color) return false;

            const directions = [
                [1, 0],  // 가로
                [0, 1],  // 세로
                [1, 1],  // 대각 ↘
                [1, -1], // 대각 ↗
            ];

            for (const [dx, dy] of directions) {
                let count = 1;
                // 정방향
                for (let step = 1; step < 5; step++) {
                    const nx = x + dx * step;
                    const ny = y + dy * step;
                    if (inBounds(nx, ny) && board[ny][nx] === color) count++;
                    else break;
                }
                // 역방향
                for (let step = 1; step < 5; step++) {
                    const nx = x - dx * step;
                    const ny = y - dy * step;
                    if (inBounds(nx, ny) && board[ny][nx] === color) count++;
                    else break;
                }
                if (count >= 5) return true;
            }
            return false;
        }

        function placeStoneByCanvasPoint(px, py) {
            if (gameOver) return;
            const rect = canvas.getBoundingClientRect();
            const scaleX = canvas.width / rect.width;
            const scaleY = canvas.height / rect.height;
            const x = (px - rect.left) * scaleX;
            const y = (py - rect.top) * scaleY;

            // 최근접 교차점 찾기
            const gridX = Math.round((x - PADDING) / CELL_SIZE);
            const gridY = Math.round((y - PADDING) / CELL_SIZE);
            if (!inBounds(gridX, gridY)) return;
            if (board[gridY][gridX] !== 0) return; // 이미 돌 있음

            board[gridY][gridX] = current;
            drawBoard();

            if (checkWinAt(gridX, gridY)) {
                statusEl.textContent = current === 1 ? '검은돌 승리!' : '흰돌 승리!';
                gameOver = true;
                return;
            }

            current = current === 1 ? 2 : 1;
            setStatus();
        }

        function resetGame() {
            board = Array.from({ length: BOARD_SIZE }, () => Array(BOARD_SIZE).fill(0));
            current = 1;
            gameOver = false;
            drawBoard();
            setStatus();
        }

        // 이벤트 바인딩
        canvas.addEventListener('click', (e) => {
            placeStoneByCanvasPoint(e.clientX, e.clientY);
        });

        canvas.addEventListener('touchstart', (e) => {
            const t = e.changedTouches[0];
            placeStoneByCanvasPoint(t.clientX, t.clientY);
            e.preventDefault();
        }, { passive: false });

        resetBtn.addEventListener('click', resetGame);

        // 초기 렌더링
        drawBoard();
        setStatus();
    </script>
</body>

</html>